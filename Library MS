#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <stdexcept>

using namespace std;

// Book Class
class Book {
private:
    string title;
    string author;
    bool isAvailable;

public:
    Book(const string& t, const string& a) : title(t), author(a), isAvailable(true) {}

    string getTitle() const { return title; }
    string getAuthor() const { return author; }
    bool getAvailability() const { return isAvailable; }
    
    void setAvailability(bool availability) { isAvailable = availability; }

    void display() const {
        cout << "Title: " << title << ", Author: " << author << ", Available: " << (isAvailable ? "Yes" : "No") << endl;
    }
};

// Member Class
class Member {
private:
    string name;
    int memberID;

public:
    Member(const string& n, int id) : name(n), memberID(id) {}

    string getName() const { return name; }
    int getMemberID() const { return memberID; }

    void display() const {
        cout << "Name: " << name << ", Member ID: " << memberID << endl;
    }
};

// Loan Class
class Loan {
private:
    Book* book;
    Member* member;

public:
    Loan(Book* b, Member* m) : book(b), member(m) {}

    Book* getBook() const { return book; }
    Member* getMember() const { return member; }
};

// Library Class
class Library {
private:
    vector<Book*> books;
    vector<Member*> members;
    vector<Loan*> loans;

    void saveData();
    void loadData();

public:
    Library() { loadData(); }
    ~Library();

    void addBook(Book* book);
    void removeBook(const string& title);
    void updateBook(const string& title, const string& newAuthor);

    void addMember(Member* member);
    void removeMember(int memberID);

    void issueBook(const string& title, int memberID);
    void returnBook(const string& title, int memberID);

    void displayBooks() const;
    void displayMembers() const;
    void displayLoans() const;
};

// Destructor to clean up dynamically allocated memory
Library::~Library() {
    for (auto book : books) delete book;
    for (auto member : members) delete member;
    for (auto loan : loans) delete loan;
}

// Add a book to the library
void Library::addBook(Book* book) {
    books.push_back(book);
    saveData();
}

// Remove a book from the library
void Library::removeBook(const string& title) {
    auto it = remove_if(books.begin(), books.end(), [&title](Book* b) { return b->getTitle() == title; });
    if (it != books.end()) {
        delete *it;
        books.erase(it, books.end());
        saveData();
    } else {
        throw runtime_error("Book not found.");
    }
}

// Update book author
void Library::updateBook(const string& title, const string& newAuthor) {
    for (auto book : books) {
        if (book->getTitle() == title) {
            // Set new author (not implemented in this simplified version)
            saveData();
            return;
        }
    }
    throw runtime_error("Book not found.");
}

// Add a member to the library
void Library::addMember(Member* member) {
    members.push_back(member);
    saveData();
}

// Remove a member from the library
void Library::removeMember(int memberID) {
    auto it = remove_if(members.begin(), members.end(), [memberID](Member* m) { return m->getMemberID() == memberID; });
    if (it != members.end()) {
        delete *it;
        members.erase(it, members.end());
        saveData();
    } else {
        throw runtime_error("Member not found.");
    }
}

// Issue a book to a member
void Library::issueBook(const string& title, int memberID) {
    Book* book = nullptr;
    Member* member = nullptr;

    for (auto b : books) {
        if (b->getTitle() == title) {
            book = b;
            break;
        }
    }

    for (auto m : members) {
        if (m->getMemberID() == memberID) {
            member = m;
            break;
        }
    }

    if (!book) throw runtime_error("Book not found.");
    if (!member) throw runtime_error("Member not found.");
    if (!book->getAvailability()) throw runtime_error("Book is not available.");

    book->setAvailability(false);
    loans.push_back(new Loan(book, member));
    saveData();
}

// Return a book
void Library::returnBook(const string& title, int memberID) {
    auto it = remove_if(loans.begin(), loans.end(), [&title, &memberID](Loan* l) {
        return l->getBook()->getTitle() == title && l->getMember()->getMemberID() == memberID;
    });

    if (it != loans.end()) {
        (*it)->getBook()->setAvailability(true);
        delete *it;
        loans.erase(it, loans.end());
        saveData();
    } else {
        throw runtime_error("Loan record not found.");
    }
}

// Display all books
void Library::displayBooks() const {
    for (auto book : books) {
        book->display();
    }
}

// Display all members
void Library::displayMembers() const {
    for (auto member : members) {
        member->display();
    }
}

// Display all loans
void Library::displayLoans() const {
    for (auto loan : loans) {
        cout << "Book: " << loan->getBook()->getTitle() << ", Member: " << loan->getMember()->getName() << endl;
    }
}

// Save data to a file
void Library::saveData() {
    ofstream bookFile("books.txt");
    ofstream memberFile("members.txt");
    ofstream loanFile("loans.txt");

    for (auto book : books) {
        bookFile << book->getTitle() << "|" << book->getAuthor() << "|" << book->getAvailability() << endl;
    }

    for (auto member : members) {
        memberFile << member->getName() << "|" << member->getMemberID() << endl;
    }

    for (auto loan : loans) {
        loanFile << loan->getBook()->getTitle() << "|" << loan->getMember()->getMemberID() << endl;
    }
}

// Load data from a file
void Library::loadData() {
    ifstream bookFile("books.txt");
    ifstream memberFile("members.txt");
    ifstream loanFile("loans.txt");

    string title, author, name;
    int memberID;
    bool isAvailable;

    while (getline(bookFile, title, '|')) {
        getline(bookFile, author, '|');
        bookFile >> isAvailable;
        bookFile.ignore();
        addBook(new Book(title, author));
    }

    while (getline(memberFile, name, '|')) {
        memberFile >> memberID;
        memberFile.ignore();
        addMember(new Member(name, memberID));
    }

    string loanTitle;
    while (getline(loanFile, loanTitle, '|')) {
        loanFile >> memberID;
        loanFile.ignore();

        Book* book = nullptr;
        Member* member = nullptr;

        for (auto b : books) {
            if (b->getTitle() == loanTitle) {
                book = b;
                break;
            }
        }

        for (auto m : members) {
            if (m->getMemberID() == memberID) {
                member = m;
                break;
            }
        }

        if (book && member) {
            loans.push_back(new Loan(book, member));
        }
    }
}

int main() {
    Library library;

    // Sample usage
    try {
        library.addBook(new Book("1984", "George Orwell"));
        library.addBook(new Book("To Kill a Mockingbird", "Harper Lee"));
        library.addMember(new Member("Alice", 1));
        library.addMember(new Member("Bob", 2));

        library.issueBook("1984", 1);
        library.returnBook("1984", 1);

        cout << "Books in library:" << endl;
        library.displayBooks();

        cout << "Members in library:" << endl;
        library.displayMembers();

        cout << "Current Loans:" << endl;
        library.displayLoans();
    } catch (const runtime_error& e) {
        cerr << "Error: " << e.what() << endl;
    }

    return 0;
}
